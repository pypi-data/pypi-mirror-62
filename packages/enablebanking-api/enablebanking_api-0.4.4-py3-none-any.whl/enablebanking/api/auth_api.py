'\n    enable:Banking SDK\n\n    enable:Banking SDK consists of 4 interfaces:  - [Meta](#auth-api) provides information about available connectors; - [Auth](#auth-api) provides PSU (bank user) authentication and token creation   functionality; - [AISP](#aisp-api) provides functions for accessing account information, such as   transactions and balances, on behalf of a PSU; - [PISP](#pisp-api) provides functions for initiating and conforming payment   requests.  The same calls and data structures are used for interacting with different ASPSPs (banks). In order to use each of the interfaces corresponding instance needs to be created. When instantiating any of the interfaces except Meta, ASPSP connector name and settings need to be supplied. The settings differ from one connector to another (although many of them have the same properties) and are described in the [Connectors](#connectors-types) section of the documentation.  enable:Banking SDK interfaces are based on [STET PSD2 specification](https://www.stet.eu/en/psd2/), but have been modified and extended in order to support usage scenarious beyond the original specification.   # noqa: E501\n\n    API version: 0.4.4\n    Contact: hello@enablebanking.com\n    Generated by enable:Banking SDK generator using Swagger Codegen project\n'
_P='POST'
_O='Token'
_N='/token'
_M='application/x-www-form-urlencoded'
_L='GET'
_K='Content-Type'
_J='Accept'
_I='application/json'
_H='kwargs'
_G='_request_timeout'
_F='_preload_content'
_E='redirect_uri'
_D=True
_C=None
_B='async_req'
_A='_return_http_data_only'
import re
from enablebanking.api_client import ApiClient
class AuthApi:
	'NOTE: This class is auto generated by the swagger code generator program.\n\n    Do not edit the class manually.\n    Ref: https://github.com/swagger-api/swagger-codegen\n    '
	def __init__(self,api_client):self.api_client=api_client
	def get_auth(self,response_type,redirect_uri,scope,**kwargs):
		'Request Authorization Data  # noqa: E501\n\n        Get authorization data such as authorization URL   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_auth(response_type, redirect_uri, scope, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str response_type: Expected response type (currently only `code` is supported) (required)\n        :param str redirect_uri: Callback URI used for redirect after PSU authentication (required)\n        :param list[str] scope: APIs, which authorization will be granted for (required)\n        :param str state: Arbitrary String to be returned from to redirect URI\n        :param str user_id: Identification of a PSU to be authenticated (used only for ASPSPs, which do not provide user interface for entering user ID on the authentication web page)\n        :param Access access: Request for access to account information This parameter should be set to override defaults for the banks, which allow PSUs to give consent for account information sharing right after authentication.\n        :return: Auth\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_A]=_D
		if kwargs.get(_B):return self.get_auth_with_http_info(response_type,redirect_uri,scope,**kwargs)
		else:data=self.get_auth_with_http_info(response_type,redirect_uri,scope,**kwargs);return data
	def get_auth_with_http_info(self,response_type,redirect_uri,scope,**kwargs):
		'Request Authorization Data  # noqa: E501\n\n        Get authorization data such as authorization URL   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_auth_with_http_info(response_type, redirect_uri, scope, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str response_type: Expected response type (currently only `code` is supported) (required)\n        :param str redirect_uri: Callback URI used for redirect after PSU authentication (required)\n        :param list[str] scope: APIs, which authorization will be granted for (required)\n        :param str state: Arbitrary String to be returned from to redirect URI\n        :param str user_id: Identification of a PSU to be authenticated (used only for ASPSPs, which do not provide user interface for entering user ID on the authentication web page)\n        :param Access access: Request for access to account information This parameter should be set to override defaults for the banks, which allow PSUs to give consent for account information sharing right after authentication.\n        :return: Auth\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';E='access';D='user_id';C='state';B='response_type';A='scope';all_params=[B,_E,A,C,D,E];all_params.append(_B);all_params.append(_A);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in params[_H].items():
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method get_auth"%key)
			params[key]=val
		del params[_H]
		if B not in params or params[B]is _C:raise ValueError('Missing the required parameter `response_type` when calling `get_auth`')
		if _E not in params or params[_E]is _C:raise ValueError('Missing the required parameter `redirect_uri` when calling `get_auth`')
		if A not in params or params[A]is _C:raise ValueError('Missing the required parameter `scope` when calling `get_auth`')
		collection_formats={};path_params={};query_params=[]
		if B in params:query_params.append((B,params[B]))
		if _E in params:query_params.append((_E,params[_E]))
		if A in params:query_params.append((A,params[A]));collection_formats[A]='csv'
		if C in params:query_params.append((C,params[C]))
		if D in params:query_params.append((D,params[D]))
		header_params={};form_params=[];local_var_files={};body_params=_C
		if E in params:body_params=params[E]
		header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_I]);auth_settings=[];return self.api_client.call_api('/auth',_L,path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type='Auth',auth_settings=auth_settings,async_req=params.get(_B),_return_http_data_only=params.get(_A),_preload_content=params.get(_F,_D),_request_timeout=params.get(_G),collection_formats=collection_formats)
	def get_current_token(self,**kwargs):
		'Get current token data  # noqa: E501\n\n        This method is used to retrieve current values of access, refresh and id tokens used for accessing AIS and PIS APIs.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_current_token(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_A]=_D
		if kwargs.get(_B):return self.get_current_token_with_http_info(**kwargs)
		else:data=self.get_current_token_with_http_info(**kwargs);return data
	def get_current_token_with_http_info(self,**kwargs):
		'Get current token data  # noqa: E501\n\n        This method is used to retrieve current values of access, refresh and id tokens used for accessing AIS and PIS APIs.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_current_token_with_http_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';all_params=[];all_params.append(_B);all_params.append(_A);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in params[_H].items():
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method get_current_token"%key)
			params[key]=val
		del params[_H];collection_formats={};path_params={};query_params=[];header_params={};form_params=[];local_var_files={};body_params=_C;header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_M]);auth_settings=[];return self.api_client.call_api(_N,_L,path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type=_O,auth_settings=auth_settings,async_req=params.get(_B),_return_http_data_only=params.get(_A),_preload_content=params.get(_F,_D),_request_timeout=params.get(_G),collection_formats=collection_formats)
	def make_token(self,grant_type,code,**kwargs):
		'Request Access Token  # noqa: E501\n\n        Requests new access token for retrieving data on behalf of the authenticated user.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.make_token(grant_type, code, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str grant_type: Value should be set to `authorization_code` or `refresh_token` depending on what passed to `code` parameter.  (required)\n        :param str code: Value of either the code received in the query string when redirected from authorization page or the refresh token used for renewing access token.  (required)\n        :param str redirect_uri: Redirect URI supplied to [`getAuth`](#getauth) function for retreival of the authorization URL. This parameter is only required for some connectors, but it is a good practice to pass it in order to unify usage for between different connectors. \n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_A]=_D
		if kwargs.get(_B):return self.make_token_with_http_info(grant_type,code,**kwargs)
		else:data=self.make_token_with_http_info(grant_type,code,**kwargs);return data
	def make_token_with_http_info(self,grant_type,code,**kwargs):
		'Request Access Token  # noqa: E501\n\n        Requests new access token for retrieving data on behalf of the authenticated user.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.make_token_with_http_info(grant_type, code, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str grant_type: Value should be set to `authorization_code` or `refresh_token` depending on what passed to `code` parameter.  (required)\n        :param str code: Value of either the code received in the query string when redirected from authorization page or the refresh token used for renewing access token.  (required)\n        :param str redirect_uri: Redirect URI supplied to [`getAuth`](#getauth) function for retreival of the authorization URL. This parameter is only required for some connectors, but it is a good practice to pass it in order to unify usage for between different connectors. \n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';B='code';A='grant_type';all_params=[A,B,_E];all_params.append(_B);all_params.append(_A);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in params[_H].items():
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method make_token"%key)
			params[key]=val
		del params[_H]
		if A not in params or params[A]is _C:raise ValueError('Missing the required parameter `grant_type` when calling `make_token`')
		if B not in params or params[B]is _C:raise ValueError('Missing the required parameter `code` when calling `make_token`')
		collection_formats={};path_params={};query_params=[];header_params={};form_params=[];local_var_files={}
		if A in params:form_params.append((A,params[A]))
		if B in params:form_params.append((B,params[B]))
		if _E in params:form_params.append((_E,params[_E]))
		body_params=_C;header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_M]);auth_settings=[];return self.api_client.call_api(_N,_P,path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type=_O,auth_settings=auth_settings,async_req=params.get(_B),_return_http_data_only=params.get(_A),_preload_content=params.get(_F,_D),_request_timeout=params.get(_G),collection_formats=collection_formats)
	def parse_redirect_url(self,redirect_url,**kwargs):
		'Parsing of redirect url during authorization  # noqa: E501\n\n        During authorization process user is redirected to a redirect url specified by TPP, where query/fragment parameters are added to the redirect url. This function parses those parameters.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.parse_redirect_url(redirect_url, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str redirect_url: Redirect url (required)\n        :return: AuthRedirect\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_A]=_D
		if kwargs.get(_B):return self.parse_redirect_url_with_http_info(redirect_url,**kwargs)
		else:data=self.parse_redirect_url_with_http_info(redirect_url,**kwargs);return data
	def parse_redirect_url_with_http_info(self,redirect_url,**kwargs):
		'Parsing of redirect url during authorization  # noqa: E501\n\n        During authorization process user is redirected to a redirect url specified by TPP, where query/fragment parameters are added to the redirect url. This function parses those parameters.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.parse_redirect_url_with_http_info(redirect_url, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str redirect_url: Redirect url (required)\n        :return: AuthRedirect\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';A='redirect_url';all_params=[A];all_params.append(_B);all_params.append(_A);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in params[_H].items():
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method parse_redirect_url"%key)
			params[key]=val
		del params[_H]
		if A not in params or params[A]is _C:raise ValueError('Missing the required parameter `redirect_url` when calling `parse_redirect_url`')
		collection_formats={};path_params={};query_params=[]
		if A in params:query_params.append(('redirectUrl',params[A]))
		header_params={};form_params=[];local_var_files={};body_params=_C;header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_I]);auth_settings=[];return self.api_client.call_api('/parseRedirectUrl',_L,path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type='AuthRedirect',auth_settings=auth_settings,async_req=params.get(_B),_return_http_data_only=params.get(_A),_preload_content=params.get(_F,_D),_request_timeout=params.get(_G),collection_formats=collection_formats)
	def set_client_info(self,**kwargs):
		'Set extra PSU headers  # noqa: E501\n\n        Set extra PSU headers such as PSU-IP-Address   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.set_client_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param ClientInfo client_info: ClientInfo object with PSU headers\n        :return: None\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_A]=_D
		if kwargs.get(_B):return self.set_client_info_with_http_info(**kwargs)
		else:data=self.set_client_info_with_http_info(**kwargs);return data
	def set_client_info_with_http_info(self,**kwargs):
		'Set extra PSU headers  # noqa: E501\n\n        Set extra PSU headers such as PSU-IP-Address   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.set_client_info_with_http_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param ClientInfo client_info: ClientInfo object with PSU headers\n        :return: None\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';A='client_info';all_params=[A];all_params.append(_B);all_params.append(_A);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in params[_H].items():
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method set_client_info"%key)
			params[key]=val
		del params[_H];collection_formats={};path_params={};query_params=[];header_params={};form_params=[];local_var_files={};body_params=_C
		if A in params:body_params=params[A]
		header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_I]);auth_settings=[];return self.api_client.call_api('/setClientInfo',_P,path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type=_C,auth_settings=auth_settings,async_req=params.get(_B),_return_http_data_only=params.get(_A),_preload_content=params.get(_F,_D),_request_timeout=params.get(_G),collection_formats=collection_formats)