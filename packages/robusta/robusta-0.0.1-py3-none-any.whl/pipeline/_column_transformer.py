import pandas as pd
import numpy as np

from sklearn.utils.metaestimators import _BaseComposition
from sklearn.base import TransformerMixin, clone
from sklearn.pipeline import _name_estimators

from ..preprocessing import Identity, ColumnSelector



__all__ = ['ColumnTransformer', 'make_column_transformer']




class ColumnTransformer(_BaseComposition, TransformerMixin):
    '''Applies transformers to columns of an array or pandas DataFrame.

    This estimator allows different columns or column subsets of the input
    to be transformed separately and the features generated by each transformer
    will be concatenated to form a single feature space. This is useful for
    combining several feature extraction mechanisms or transformations
    into a single transformer.

    Parameters
    ----------
    transformer_list : list
        List of (string, transformer, columns) tuples (implementing fit/transform).

    remainder : {'drop', 'pass'} or estimator, default 'drop'
        By default, only the specified columns in `transformer_list` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).
        By specifying ``remainder='pass'``, all remaining columns that
        were not specified in `transformer_list` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.
        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support `fit` and `transform`.

    Attributes
    ----------
    transformers_ : list
        The collection of fitted transformers as tuples of (name, fitted_transformer,
        column). fitted_transformer can be an estimator, ‘drop’, or ‘pass’.
        In case there were no columns selected, this will be the unfitted transformer.

        If there are remaining columns, the final element is a tuple of the form:
        (‘remainder’, transformer, remaining_columns_) corresponding to the remainder
        parameter. If there are remaining columns, then
        len(transformers_)==len(transformers)+1, otherwise
        len(transformers_)==len(transformers).

    named_transformers_ : Bunch object, a dictionary with attribute access
        Access the fitted transformer by name.

    remaining_columns_ : list of strings
        List of remining columns.

    '''
    def __init__(self, transformer_list, remainder='drop', **kwargs):
        self.transformer_list = transformer_list
        self.remainder = remainder


    @property
    def _transformers(self):
        """
        Internal list of transformer only containing the name and
        transformers, dropping the columns. This is for the implementation
        of get_params via BaseComposition._get_params which expects lists
        of tuples of len 2.
        """
        return [(name, trans) for name, trans, _ in self.transformer_list]


    def fit(self, X, y=None):
        """Fit all transformers using X.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        y : array-like, shape (n_samples, ...), optional
            Targets for supervised learning.

        Returns
        -------
        self : ColumnTransformer
            This estimator

        """
        self.transformers_ = []
        self.named_transformers_ = {}
        self.remaining_columns_ = set(X.columns)

        for name, transformer, cols in self.transformer_list:
            # Clone & fit
            fitted_transformer = clone(transformer).fit(X[cols], y)
            self.named_transformers_[name] = fitted_transformer
            # Access by key
            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)
            # Remainin columns
            self.remaining_columns_ -= set(cols)

        self.remaining_columns_ = list(self.remaining_columns_)
        if self.remaining_columns_:

            name, cols = 'remainder', self.remaining_columns_

            if hasattr(self.remainder, 'fit') and hasattr(self.remainder, 'transform'):
                fitted_transformer = clone(self.remainder).fit(X[cols], y)

            elif self.remainder is 'pass':
                fitted_transformer = Identity().fit(X[cols], y)

            elif self.remainder is 'drop':
                fitted_transformer = ColumnSelector(cols=[]).fit(X[cols], y)

            else:
                raise ValueError('Unknown type for remainder. Must be "drop", "pass" or estimator.')

            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)

        return self


    def transform(self, X):
        """Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        Returns
        -------
        Xt : DataFrame, shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.

        """
        Xt_list = []
        for name, transformer, cols in self.transformers_:
            Xt_list.append(transformer.transform(X[cols]))

        Xt = pd.concat(Xt_list, axis=1)
        return Xt


    def get_params(self, deep=True):
        """Get parameters for this estimator.

        Parameters
        ----------
        deep : boolean, optional
            If True, will return the parameters for this estimator and
            contained subobjects that are estimators.
        Returns
        -------
        params : mapping of string to any
            Parameter names mapped to their values.

        """
        return self._get_params('_transformers', deep=deep)


    def set_params(self, **kwargs):
        """Set the parameters of this estimator.

        Valid parameter keys can be listed with ``get_params()``.

        Returns
        -------
        self

        """
        self._set_params('_transformers', **kwargs)
        return self




def _get_transformer_list(estimators):
    """
    Construct (name, trans, column) tuples from list
    """
    message = ('`make_column_transformer` expects (transformer, columns)')

    transformers, columns = zip(*estimators)

    names, _ = zip(*_name_estimators(transformers))

    transformer_list = list(zip(names, transformers, columns))
    return transformer_list




def make_column_transformer(*transformers, **kwargs):
    """Construct a ColumnTransformer from the given transformers.

    This is a shorthand for the ColumnTransformer constructor; it does not
    require, and does not permit, naming the transformers. Instead, they will
    be given names automatically based on their types. It also does not allow
    weighting with ``transformer_weights``.

    Parameters
    ----------
    *transformers : tuples of transformers and column selections

    remainder : {'drop', 'pass'} or estimator, default 'drop'
        By default, only the specified columns in `transformers` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).

        By specifying ``remainder='pass'``, all remaining columns that
        were not specified in `transformers` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.

        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support `fit` and `transform`.

    sparse_threshold : float, default = 0.3

        If the transformed output consists of a mix of sparse and dense data,
        it will be stacked as a sparse matrix if the density is lower than this
        value. Use ``sparse_threshold=0`` to always return dense.
        When the transformed output consists of all sparse or all dense data,
        the stacked result will be sparse or dense, respectively, and this
        keyword will be ignored.

    n_jobs : int or None, optional (default=None)
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
        for more details.

    Returns
    -------
    ct : ColumnTransformer

    """
    # transformer_weights keyword is not passed through because the user
    # would need to know the automatically generated names of the transformers
    n_jobs = kwargs.pop('n_jobs', None)
    remainder = kwargs.pop('remainder', 'drop')
    sparse_threshold = kwargs.pop('sparse_threshold', 0.3)

    if kwargs:
        raise TypeError('Unknown keyword arguments: "{}"'.format(list(kwargs.keys())[0]))

    transformer_list = _get_transformer_list(transformers)

    return ColumnTransformer(transformer_list, n_jobs=n_jobs, remainder=remainder,
                             sparse_threshold=sparse_threshold)
