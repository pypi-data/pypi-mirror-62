Metadata-Version: 2.1
Name: legume-gme
Version: 0.0.2
Summary: Differentiable plane-wave and guided-mode expansion for photonic crystals
Home-page: https://github.com/fancompute/legume
Author: Momchil Minkov
Author-email: momchilmm@gmail.com
License: UNKNOWN
Description: # legume
        
        legume (le GUided Mode Expansion) is a python implementation of the GME method for photonic crystal slabs, including support for multi-layer structures. Plane-wave expansion for purely 2D structures is also included. 
        
        ## Install
        
        Eventually this should be `pip` installable from PyPi, but for now hopefully this will work for you:
        
        ```
        git clone https://github.com/fancompute/legume.git
        pip install -e legume
        pip install -r legume/requirements.txt
        ```
        
        Alternatively just `git clone` it, make sure you have all the requirements installed, and add the path to the folder in your python path: `export PYTHONPATH=$PYTHONPATH:/path/to/the/location/of/legume`.
        
        ## Autograd
        
        One exciting feature is the `autograd` backend that can be used to automatically compute the gradient of the eigenmodes and eigenfrequencies with respect to any input parameters! When running GME, you can specify `'gradients' = 'exact'` (default), or `'gradients' = 'approx'` (faster). The latter discards the gradient due to the guided mode basis itself and only keeps the gradients from the diagonalization. Here are some rules of thumb on what to use:
        
        - If you're optimizing hole positions (i.e. parameters that don't change the average permittivity), you're in luck! In this case, the `approx` gradients should actually be **exact**! 
        - If you're optimizing dispersion (real part of eigenfrequencies) w.r.t. parameters that do **not** include the layer thicknesses, you could still try using `approx` gradients, as they might be within just a few percent of the exact ones. 
        - If you're optimizing loss rates (imaginary part of eigenfrequencies) and/or if your parameters include the layer thicknesses, then the `approx` gradients could be significantly off, `exact` is recommended. 
        
        ## Guided-mode computation options
        `GuidedModeExp.run()` takes a number of optional arguments. Below is a list of the most important ones, with a short explanation.
        
        - `gmode_compute: {'exact'}, 'interp'` Define whether the guided modes are computed in the beginning and then interpolated, or whether they are computed exactly at every k-step.
        - `gmode_inds: {[0]}, list/numpy array` List of indexes of the guided bands to be included in the expansion. These alternate between TE and TM defined with respect to the propagation direction.
        - `numeig: {10}, int` Number of eigen-frequencies to be stored.
        - `eig_sigma: {0.}, float` Target frequency, the closest `numeig` eigen-frequencies are stored.
        - `compute_im: {True}, bool` Specifies if the imaginary parts of the frequencies should also be computed.
        - `gradients: {'exact'}, 'approx'` Specifies whether to compute exact gradients, or approximate (faster)
        - `eps_eff: {'average'}, 'background'` Using the 'average' or the 'background' permittivity of the layers in the guided mode computation.
        - `verbose: {True}, bool` Print information at intermmediate steps.
        
        ## Convergence
        
        If you think the GME run might not be fully converged, I suggest changing the parameters in the following order:
        
        - First, make sure you have a high enough `gmax`, which is defined upon initialization of `GuidedModeExp`.
        - Then, include higher-order modes by increasing the number of indexes included in `options['gmode_inds']`.
          - Note that after including more modes in `gmode_inds`, you should test again the convergence w.r.t. `gmax`.
        
        Note that GME is, in the end, only an approximate method, so even if it is converged with respect to the above parameters but produces strange results, it might be that it's not that well-suited for the structure you are simulating.
        
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Description-Content-Type: text/markdown
