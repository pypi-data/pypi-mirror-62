#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Set encoding default for python 2.7
# vim: syntax=python noexpandtab

# gadgetconfig configures and enables a Gadget USB configuration
#

import os
import sys

import io
import libconf
import argparse
import json
import shutil

import fnmatch
import magic
import struct
from termcolor import colored

"""manage.py: ..."""

# __author__  = "Stuart.Lynne@belcarra.com"



class ManageGadget(object):

	def __init__(self, configpath):
		self.configpath = configpath
		self.udcpath = "/sys/class/udc"
		self.device = None
		self.udclist = []
		self.configured_device = ''


	def pathread(self, path):

		#print("pathread: %s" % (path))
		try:
			fstat = os.stat(path)
			# print("fstat: size:%s" % (fstat.st_size))
		except (PermissionError):
			print("pathread: %s PERMISSION ERROR" % (path))
			return ''
		except (FileNotFoundError):
			print("pathread: %s NOT FOUND" % (path))
			return ''

		# 4096 or 0 byte files should contain info
		if fstat.st_size == 4096 or fstat.st_size == 0:
			try:
				f = open(path, "r")
				lines = f.readlines(1000)
				f.close()
				return lines
			except (PermissionError, OSError):
				return ''
			except UnicodeDecodeError:
				return '[UnicodeDecodeError]'

		return '<UNKNOWN>'


	def vprint(self, verbose, s):
		if verbose:
			print(s)

	# checkfs will verify that the usb_gadget configfs is available
	#
	def checkfs(self, verbose=False):
		try:
			if not os.path.isdir(self.configpath):
				self.vprint(verbose, "%s: not a directory" % (self.configpath))
				return False
			if os.path.islink(self.configpath):
				self.vprint(verbose, "%s: is a symlink to %s" % (self.configpath, os.path.realpath(self.configpath)))
				return False
			return True
		except PermissionError:
			self.vprint(verbose, "Cannot read: %s PermissionError" % (self.configpath))
		except NameError:
			self.vprint(verbose, "Cannot read: %s NameError" % (self.configpath))
		return False

	# def detach(self):
	#
	def find_udcs(self, verbose=False):
		links = os.listdir(self.udcpath)
		self.udclist = []
		self.vprint(verbose, "Gadget UDCS")
		for l in links:
			fpath = "%s/%s" % (self.udcpath, l)
			if os.path.islink(fpath):
				self.udclist.append(l)
				self.vprint(verbose, "  %s -> %s" % (l, os.path.realpath(fpath)))
				device = self.pathread("%s/function" % (fpath))
				if device is not None and len(device) > 0:
					self.device = device[0].rstrip()
					self.vprint(verbose, "  Device definition: %s" % (self.device))
			else:
				self.vprint(verbose, "  %s <UNKNOWN>" % (l))
		self.vprint(verbose, "")
		return self.udclist


	def check_current(self, verbose=False):
		dirs = os.listdir(self.configpath)
		self.vprint(verbose, "Current Gadget configurations")
		if len(dirs) == 0:
			self.vprint(verbose, "<NONE>")

		#print("check_current: %s" % (self.configpath))
		#print("check_current: dirs: %s" % (dirs))
		for d in dirs:
			udc = self.pathread(("%s/%s/UDC" % (self.configpath, d)))
			#print("udc: type: %s len: %s" % (type(udc),len(udc)))
			if len(udc) == 1 and len(udc[0]) > 1:
				#print("udc: type: %s len: %s" % (type(udc[0]),len(udc[0])))
				self.vprint(verbose, "  %s UDC -> %s" % (d, udc[0].rstrip()))
				self.configured_device = d
			else:
				self.vprint(verbose, "  %s Not Configured" % (d))
		self.vprint(verbose, "")

	def disable_current(self):
		if self.device is None:
			print("The Gadget UDC is currently not configured!")
			return

		print("Gadget UDC configured to USB Device %s" % (self.device))
		udcpath = "%s/%s/UDC" % (self.configpath, self.device)
		print("writing to: %s" % (udcpath))
		f = open(udcpath, 'w') 
		f.write("\n")
		f.close()

	def enable(self, config_name):
		if self.device is not None:
			print("The Gadget UDC is currently configured!")
			return

	def rmdir(self,path):
		if not os.path.isdir(path):
			print("rmdir: %s NOT A DIR" % (path))
			return
		print("rmdir: %s" % (path))
		os.rmdir(path)

	def unlink(self,path):
		if not os.path.islink(path):
			print("rmdir: %s NOT A SYMLINK" % (path))
			return
		print("unlink: %s" % (path))
		os.unlink(path)

	def listdir(self,path):
		if not os.path.isdir(path):
			print("listdir: %s NOT A DIR" % (path))
			return
		print("listdir: %s" % (path))
		return os.listdir(path)



	def remove_strings(self, path):
		spath = "%s/strings" % path
		if os.path.isdir(spath):
			for l in os.listdir(spath):
				self.rmdir("%s/%s" % (spath, l))

		#self.rmdir(spath)

	# C.f. gadget_configfs.txt - section 7. Cleaning up
	# For each configuration .../configs/*
	# 1. unlink Functions 
	# 2. rmdir strings/<lang> 
	# 3. rmdir config
	# 4. rmdir functions/*
	# 5. rmdir strings/<lang>
	# 6. rmdir device 
	#
	def remove_device(self, configname):

		# sanity checks, verify device is not currently enabled	
		if configname == self.device:
			print("The %s Gadget USB Device is currently enabled!" % (configname))
			exit(1)

		# sanity checks, verify usb_gadget/configname exists and we have permissions
		device_path = "%s/%s" % (self.configpath, configname)
		try:
			fstat = os.stat(device_path, follow_symlinks=False)
		except (FileNotFoundError):
			print("%s FILE NOT FOUND ERROR" % (device_path))
			exit(1)
		except (PermissionError):
			print("%s PERMISSION ERROR" % (device_path))
			exit(1)

		# iterate across device path configs directory to handle
		# steps #1, #2 and #3 for each configuration
		#
		configs_path = "%s/configs" % (device_path)
		for c in self.listdir(configs_path):
			print("remove_device: config: %s" % (c))

			# 1.
			config_path = "%s/%s" % ( configs_path, c)
			for e in self.listdir(config_path):
				self.unlink("%s/%s" % (config_path, e))
			# 2.
			self.remove_strings(config_path)
			# 3.
			self.rmdir(config_path)


		# iterate across device path / functions so we can
		# perform step #4, rmdir each 
		functions_path = "%s/functions" % (device_path)
		for f in self.listdir(functions_path):
			# 4.
			self.rmdir("%s/%s" % (functions_path, f))

		# Finally for device path, do step #5 remove strings and then step #6 remove the device
		#
		# 5.
		self.remove_strings(device_path)
		# 6.
		self.rmdir(device_path)



	def export_attrs(self, directory_path):
		if not os.isdir(directory_path):
			print("%s is NOT A DIRECTORY" % (directory_path))
			return
		attrs = {}
		for e in os_listdir(directory_path):
			if e == 'UDC':
				continue
			v = self.pathread("%s/%s" % (directory_path, e))
			if v is not None and len(v) > 0:
				attrs[e] = v[0]
		print("export_attrs: %s" % (attrs))
		return attrs

	def export_strings(self, directory_path):
		if not os.isdir(directory_path):
			print("%s is NOT A DIRECTORY" % (directory_path))
			return
		strings = []
		for l in os_listdir("%s/strings" % (directory_path)):
			lang_strings['lang'] = l
			for s in os_listdir("%s/strings/%s" % (directory_path, l)):
				v = self.pathread("%s/%s" % (directory_path, s))
				if v is not None and len(v) > 0:
					lang_strings[s] = v[0]
			strings.append(lang_strings)
		return strings

	def export_os_descs(self, directory_path):
		if not os.isdir(directory_path):
			print("%s is NOT A DIRECTORY" % (directory_path))
			return
		os_descs = []
		for o in os_listdir("%s/os_desc" % (directory_path)):
			v = self.pathread("%s/%s" % (directory_path, o))
			if v is not None and len(v) > 0:
				os_descs[o] = v[0]
		return os_descs

	def export_os_functions(self, directory_path):
		if not os.isdir(directory_path):
			print("%s is NOT A DIRECTORY" % (directory_path))
			return
		functions = []
		for f in os_listdir("%s/functions" % (directory_path)):
			function = []
			realpath = os.path.realpath(f)
			(head, tail) = os.path.split(realpath)
			(type, instance) = tail.split(".")
			function['type'] = type;
			function['instance'] = instance;
			function['attrs'] = self.export_attrs("%s/functions/%s/" % (directory_path, f))
			function['os_descs'] = self.export_attrs("%s/functions/%s/os_descs" % (directory_path, f))
			functions.append(function)
		return functions

	def export_os_configs(self, directory_path):
		if not os.isdir(directory_path):
			print("%s is NOT A DIRECTORY" % (directory_path))
			return
		configs = []
		for f in os_listdir("%s/configs" % (directory_path)):
			config = []
			for c in os_listdir("%s/configs/%s" % (directory_path, f)):

				cpath = "%s/configs/%s/%s" % (directory_path, f, c)
				if os.isdir(cpath):
					realpath = os.path.realpath(f)
					target = os.path.split(realpath)
					configs[f] = target
				v = self.pathread("%s/%s" % (directory_path, s))
				if v is not None and len(v) > 0:
					lang_strings[s] = v[0]

			configs[f] = config
		return



#	def export(self, devicename):
#		self.devicename = devicename
#
#		# sanity checks, verify usb_gadget/configname exists and we have permissions
#		device_path = "%s/%s" % (self.configpath, configname)
#		try:
#			fstat = os.stat(device_path, follow_symlinks=False)
#		except (FileNotFoundError):
#			print("%s FILE NOT FOUND ERROR" % (device_path))
#			exit(1)
#		except (PermissionError):
#			print("%s PERMISSION ERROR" % (device_path))
#			exit(1)
#
#		attrs = self.export_attrs(device_path)
#		strings = self.export_strings(device_path)
#		os_descs = self.export_os_descs(device_path)
#		functions = self.export_functions(device_path)
#		os_configs = self.export_os_configs(device_path)


